// This file defines protobuf protocol for Satellite <> Electric replication
// Messages are sent over the wire in the following format:
//
// Size:32, MsgType:8, Msg/binary
//
// In this document there is a notation of the Client/Server and
// Producer/Consumer which are used to annotate messages.
//
// Server is expected to be one of the Electric instances, while Client is a
// client application that talks to Electric via Satellite library, or any other
// entity that implements this protocol.
//
// Producer and Consumer are the corresponding roles Client and Server play in
// replication process. Consumer requests replication from the Producer, and
// periodically answer Ping requests form the Producer to acknowledge
// successful replication. Consumer may also send such Ping requests, if the
// bidirectional replication is enabled. If one of the parties is not involved
// in the replication lsn field may be left empty.
syntax = "proto3";

// NOTE: Part after Electric.Satellite is used as a version of the protocol
// itself where the format vMAJOR_MINOR is treated in the following way:
//
//   - MAJOR version is incremented when breaking API changes are introduced
//
//   - MINOR version is incremented when new API or bugfixes are introduced
//     in a backwards-compatible manner
//
package Electric.Satellite.v1_4;

// Ping request. Can be sent by any party.
message SatPingReq{
}

// Ping response.
message SatPingResp{
    // If LSN is present, it conveys to producer the latest LSN position that
    // was applied on the consumer side. If there is no active replication
    // ongoing the field should be left empty.
    optional bytes lsn = 1;
}

enum SatAuthHeader {
    // Required by the Protobuf spec.
    UNSPECIFIED = 0;

    // required header
    // protobuf protocol version, this version is picked from
    // the package statement of this protobuf file, for example "Electric.Satellite.v10_13"
    PROTO_VERSION = 1;

    // required header
    // last schema version applied on the client. Is prepended with the hash
    // algorithm type, for example: "sha256:71c9f..."
    SCHEMA_VERSION = 2;
}

message SatAuthHeaderPair {
    SatAuthHeader key = 1;
    string value = 2;
}

// (Client) Auth request
//
// Client request is the first request that the client should send before
// executing any other request.
message SatAuthReq {
    // Identity of the Satellite application. Is expected to be something like
    // UUID. Required field
    string id = 1;
    // Authentication token, auth method specific, required
    string token = 2;
    // Headers, required
    repeated SatAuthHeaderPair headers = 3;
}

// (Server) Auth response
message SatAuthResp {
    // Identity of the Server
    string id = 1;
    // Headers optional
    repeated SatAuthHeaderPair headers = 3;
}

// General purpose error message, that could be sent to any request from any
// side. FIXME: We might want to separate that into Client/Server parts.
message SatErrorResp {
    enum ErrorCode {
        INTERNAL = 0;
        AUTH_REQUIRED = 1;
        AUTH_FAILED = 2;
        REPLICATION_FAILED = 3;
        INVALID_REQUEST = 4;
        PROTO_VSN_MISMATCH = 5;
        SCHEMA_VSN_MISMATCH = 6;
    }

    ErrorCode error_type = 1;
}

// (Consumer) Starts replication stream from producer to consumer
message SatInStartReplicationReq {
    enum Option {
        NONE = 0;
        // Flag that indicates to Producer, to start replication from the latest
        // position that has been acknowledged by this Consumer. In such a case
        // provided lsn will be ignored
        LAST_ACKNOWLEDGED = 1;
        // In sync mode consumer of the stream is expected to send SatPingResp
        // message for every committed batch of SatOpLog messages
        SYNC_MODE = 2;
        // Asks receiver to start replication from the first transaction in the log
        // without necessity to know about the actual internal format of the LSN
        FIRST_LSN = 3;
        // Asks receiver to start replication from the last position in the log,
        // whatever this position is. Used for tests only.
        LAST_LSN = 4;
    }
    // LSN position of the log on the producer side
    bytes lsn = 1;
    repeated Option options = 2;
    // Amount of message after which SatPingResp message is expected to be
    // delivered when SYNC_MODE is used
    int32 sync_batch_size = 3;

    // the subscriptions identifiers the client wants to resume subscription    
    repeated string subscription_ids = 4;

    // The version of the most recent migration seen by the client.
    optional string schema_version = 5;

    // Note:
    // - a client might resume replication only for a subset of previous subscriptions 
    // in case the application cancelled some subscriptions while disconnected from the
    // server. The server is responsible to keep/gc the remaining subscriptions.
    // - the server must ensure that if the client skips a portion of the replication
    // stream, the client is not able to read data it no longer has access to.
}

// (Producer) The result of the start replication requests
message SatInStartReplicationResp {
    // returned in case replication fails to start
    optional ReplicationError err = 1;

    // Error returned by the Producer when replication fails to start
    message ReplicationError {
        // error code enum
        enum Code {
            // Required by the Protobuf spec.
            CODE_UNSPECIFIED = 0;

            // requested LSN is behind the current replication window
            BEHIND_WINDOW = 1;

            // e.g. jumping ahead of the subscriptions cursor
            INVALID_POSITION = 2;

            // requested subscription not found
            SUBSCRIPTION_NOT_FOUND = 3;
        }

        // error code
        Code code = 1;

        // a human-readable description of the error
        string message = 2;
    }
}

// (Consumer) Request to stop replication
message SatInStopReplicationReq {

}

// (Producer) Acknowledgement that replication has been stopped
message SatInStopReplicationResp {

}

message SatRelationColumn {
    string name = 1;
    string type = 2;
    bool primaryKey = 3;
}

message SatRelation {
    enum RelationType {
        TABLE = 0;
        INDEX = 1;
        VIEW = 2;
        TRIGGER = 3;
    }

    string schema_name = 1;
    RelationType table_type = 2;
    string table_name = 3;
    // Volatile identity defined at the start of the replication protocol may or
    // may not be persisted is used in SatTransOp operations, to indicate
    // relation the operation is working on.
    uint32 relation_id = 4;
    repeated SatRelationColumn columns = 5;
}

// Time granularity.
// -----------------
// commit timestamps have microseconds granularity

// (Producer) Type defines replication messages, that flow from Producer once
// the replication is established. Message contains operations log. Operations
// should go in the LSN order. Begin and Commit operations corresponds to
// transaction boundaries.
// Transactions are guranteed not to be mixed, and will follow one by one.
message SatOpLog {
    repeated SatTransOp ops = 1;
}

// (Producer) Single operation, should be only send as part of the SatOplog
// message
message SatTransOp {
    oneof op {
        SatOpBegin  begin = 1;
        SatOpCommit commit = 2;
        SatOpUpdate update = 3;
        SatOpInsert insert = 4;
        SatOpDelete delete = 5;
        SatOpMigrate migrate = 6;
    }
}

// (Producer) Replication message that indicates transaction boundaries
// should be only send as payload in the SatTransOp message
message SatOpBegin {
    uint64 commit_timestamp = 1;
    string trans_id = 2;
    // Lsn position that points to first data segment of transaction in the
    // WAL
    bytes lsn = 3;
    // Globally unique id of the source that transaction originated from. For
    // data coming from Satellite this field is ignored. For data coming from
    // Electric this field can be used to deduce if the incoming transaction
    // originated on this Satellite instance or not.
    optional string origin = 4;
    // does this transaction contain ddl statements?
    bool is_migration = 5;
}

// (Producer) Replication message that indicates transaction boundaries
// should be only send as payload in the SatTransOp message
message SatOpCommit {
    uint64 commit_timestamp = 1;
    string trans_id = 2;
    bytes lsn = 3;
}

// (Producer) Data manipulation message, that only should be part of the
// SatTransOp message
message SatOpInsert {
    uint32 relation_id = 1;
    SatOpRow row_data = 2;
    // dependency information
    repeated string tags = 3;

}

// (Producer) Data manipulation message, that only should be part of the
// SatTransOp message
message SatOpUpdate {
    uint32 relation_id = 1;
    SatOpRow row_data = 2;
    SatOpRow old_row_data = 3;
    // dependency information
    repeated string tags = 4;
}

// (Producer) Data manipulation message, that only should be part of the
// SatTransOp message
message SatOpDelete {
    uint32 relation_id = 1;
    SatOpRow old_row_data = 2;
    // dependency information
    repeated string tags = 3;

}

// Message is sent when server is migrated while client is still connected It's
// up to the client to immediately perform a migration or stop replication
// stream if it's ongoing.
message SatMigrationNotification {
    // all fields are required
    string old_schema_version = 1;
    string old_schema_hash = 2;
    string new_schema_version = 3;
    string new_schema_hash = 4;
}

// Dependency information for row data.
// ------------------------------------
//
// Tags in a row is a set of strings, where each tag is textual representation
// of conacatenation of `origin` and `commit_timestamp`, that can be obtained
// from SatOpBegin message.
// Format: origin@commit_timestamp
// Example: fcb57d30-95ce-4d75-b295-c08c7a1e75d8@1674210220785123

// Message that corresponds to the single row.
message SatOpRow {
    bytes nulls_bitmask = 1;
    // values may contain binaries with size 0 for NULLs and empty values
    // check nulls_bitmask to differentiate between the two
    repeated bytes values = 2;
}

// A migration message, originating in Postgres, captured via event triggers,
// propagated to electric, converted from postgres to the equivalent sqlite
// statement and inserted into the replication stream
//
// Each migration message includes the sql strings to execute on the satellite
// client as well as metadata information about the resulting structure of the
// changed tables.
message SatOpMigrate {
    enum Type {
        CREATE_TABLE = 0;
        CREATE_INDEX = 1;
        ALTER_ADD_COLUMN = 6;
    }
    message Stmt {
        Type type = 1;
        string sql = 2;
    }
    message PgColumnType {
        // the pg type name, e.g. int4, char
        string name = 1;
        // array dimensions, or [] for scalar types
        // e.g. for a column declared as int4[][3], size = [-1, 3]
        repeated int32 array = 2;
        // any size information, e.g. for varchar(SIZE) or [] for no size
        repeated int32 size = 3;
    }
    message Column {
        string name = 1;
        string sqlite_type = 2;
        PgColumnType pg_type = 3;
    }
    message ForeignKey {
        // the columns in the child table that point to the parent
        repeated string fk_cols = 1;
        // the parent table
        string pk_table = 2;
        // the cols in the parent table
        repeated string pk_cols = 3;
    }
    message Table {
        string name = 1;
        repeated Column columns = 2;
        repeated ForeignKey fks = 3;
        repeated string pks = 4;
    }
    // the migration version as specified by the developer and put into
    // the postgresql migration as an electric function call
    string version = 1;
    // a list of sql ddl statements to apply, converted from the pg originals
    // The migration machinery converts an `ALTER TABLE action1, action2, action3;`
    // query into a set of 3: `ALTER TABLE action1; ALTER TABLE action2,` etc
    // so we need to support 1+ statements for every migration event.
    repeated Stmt stmts = 2;
    // The resulting table definition after applying these migrations
    // (a DDL statement can only affect one table at a time).
    optional Table table = 3;
}

// (Consumer) Request for new subscriptions
message SatSubsReq {
    // a client-generated identifier to track the subscription
    string subscription_id = 1;

    // Shape requests
    repeated SatShapeReq shape_requests = 2;
}

// (Producer) Response for a subscription request
message SatSubsResp {
    // identifier of the subscription this response refers to
    string subscription_id = 1;

    // the error details if the request failed
    optional SatSubsError err = 2;

    // Error message returned by the Producer when it encounters
    // an error handling subscription request
    message SatSubsError {
        
        // error code enum
        enum Code {
            // Required by the Protobuf spec.
            CODE_UNSPECIFIED = 0;
            
            // DUPLICATE IDENTIFIER
            SUBSCRIPTION_ID_ALREADY_EXISTS = 1;

            // Error requesting shape
            SHAPE_REQUEST_ERROR = 2;
        }

        // error code
        Code code = 2;

        // A human-readable description of the error
        string message = 3;

        // Details of the shape request error
        repeated ShapeReqError shape_request_error = 4;

        // Shape request error
        message ShapeReqError {
            // error code enum
            enum Code {
                // Required by the Protobuf spec.
                CODE_UNSPECIFIED = 0;

                // Table does not exist in current schema version
                TABLE_NOT_FOUND = 1;

                // Requested shape does not maintain referential integirty
                REFERENTIAL_INTEGRITY_VIOLATION = 2;
            }

            // error code
            Code code = 1;

            // a human-readable description of the error
            string message = 2;

            // the shape request identifier that this error refers to
            string request_id = 3;
        }
    }
}

// (Consumer) Request to cancel subscriptions
message SatUnsubsReq {
    // Identifiers of the subscriptions
    repeated string subscription_ids = 1;
}

// (Producer) Acknowledgment that the subscriptions were cancelled
message SatUnsubsResp {    
}

// Shape request
message SatShapeReq {
    // Identifier of the request
    string request_id = 1;

    // The shape definition
    SatShapeDef shape_definition = 2;
}

// Top-level structure of a shape definition
message SatShapeDef {
    // Select structure
    message Select {
        // table name for this select
        string tablename = 1;
    }

    // Selects for the Shape definition
    repeated Select selects = 1;
}

// Error message returned by the Producer when it encounters
// an error handling subscription data
message SatSubsDataError {
    // error code enum
    enum Code {
        // Required by the Protobuf spec.
        CODE_UNSPECIFIED = 0;

        // Error delivering shape
        SHAPE_DELIVERY_ERROR = 1;
    }

    // error code
    Code code = 1;

    // A human-readable description of the error
    string message = 2;

    // Subscription identifier this error refers to
    string subscription_id = 3;

    // Details of the shape request error
    repeated ShapeReqError shape_request_error = 4;

    // Shape request error
    message ShapeReqError {
        // error code enum
        enum Code {
            // Required by the Protobuf spec.
            CODE_UNSPECIFIED = 0;

            // Requested shape exceed the maximum allowed shape size
            SHAPE_SIZE_LIMIT_EXCEEDED = 1;
        }

        // error code
        Code code = 1;

        // a human-readable description of the error
        string message = 2;

        // the shape request identifier that this error refers to
        string request_id = 3;
    }
}

// Begin delimiter for the incoming subscription data
message SatSubsDataBegin {
    // Identifier of the subscription
    string subscription_id = 1;
}

// End delimiter for the incoming subscription data
message SatSubsDataEnd {
}

// Begin delimiter for the initial shape data
message SatShapeDataBegin {
    // Identifier of the request
    string request_id = 1;
    // The UUID of the shape on the Producer
    string uuid = 2;
}

// End delimiter for the initial shape data
message SatShapeDataEnd {
}
