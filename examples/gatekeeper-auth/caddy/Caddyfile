{
  order jwtauth before basicauth
}

:8080 {
  jwtauth {
    # You can sign and validate JWT tokens however you prefer. Here we
    # expect tokens to have been signed with the `HS256` algorithm and
    # a shared symmetric signing key to match the configuration in
    # `../api/lib/api/token.ex`, so that this example config validates
    # tokens generated by the example Api service.
    #
    # Note that the signing key should be base64 encoded:
    #
    #     sign_key "<secret_key_bytes_in_base64_format>"
    #
    # See https://caddyserver.com/docs/modules/http.authentication.providers.jwt
    sign_key {$AUTH_SECRET:"TkZMNSowQmMjOVU2RUB0bm1DJkU3U1VONkd3SGZMbVk="}
    sign_alg HS256

    # The jwtauth module requires a user claim but we don't actually use
    # it here, so we just set it to the token issuer.
    user_claims iss

    # Extract the shape definition from the JWT `shape` claim and write
    # into {http.auth.user.*} variables, so e.g.: the `shape.table`
    # becomes {http.auth.user.table} and is used below to match against
    # the request parameters.
    meta_claims \
      "shape.namespace -> namespace" \
      "shape.table -> table" \
      "shape.where -> where" \
      "shape.columns -> columns"
  }

  # Match `GET /v1/shape` requests.
  @get_shape {
    method GET

    path /v1/shape
  }

  # Match requests whose JWT shape definition matches the shape definition
  # in the request parameters.
  #
  # So, for example, a claim of `{"shape": {"table": "items"}}` will match
  # a query parameter of `?table=items`.
  #
  # Note that the first part of the expression matches the request table
  # param against either the shape `table` or `namespace.table` depending
  # on whether the shape `namespace` is empty or not.
  @definition_matches {
    expression <<CEL
      (
        {http.auth.user.namespace} == ""
        ? {http.auth.user.table} == {http.request.uri.query.table}
        : {http.auth.user.namespace} + "." + {http.auth.user.table} == {http.request.uri.query.table}
      )
      && {http.auth.user.where} == {http.request.uri.query.where}
      && {http.auth.user.columns} == {http.request.uri.query.columns}
    CEL
  }

  # Route the request according to the matchers.
  handle @get_shape {
    handle @definition_matches {
      reverse_proxy {$ELECTRIC_URL:"http://localhost:3000"}
    }

    respond "Forbidden" 403 {
      close
    }
  }

  respond "Not found" 404 {
    close
  }
}
