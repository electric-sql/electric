import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { main } from '../src/cli.js'

// Mock the dependencies
vi.mock('../src/electric-api.js', () => ({
  provisionElectricResources: vi.fn(),
}))

vi.mock('../src/template-setup.js', () => ({
  setupTemplate: vi.fn(),
}))

// Mock console methods
const mockConsoleLog = vi.fn()
const mockConsoleError = vi.fn()
const mockProcessExit = vi.fn()

vi.stubGlobal('console', {
  log: mockConsoleLog,
  error: mockConsoleError,
})

Object.defineProperty(process, 'exit', {
  value: mockProcessExit,
  writable: true,
})

describe('cli', () => {
  const originalArgv = process.argv
  let mockProvisionElectricResources: any
  let mockSetupTemplate: any

  beforeEach(async () => {
    const electricApiMock = await vi.importMock('../src/electric-api.js')
    const templateSetupMock = await vi.importMock('../src/template-setup.js')
    
    mockProvisionElectricResources = electricApiMock.provisionElectricResources
    mockSetupTemplate = templateSetupMock.setupTemplate
    
    // Reset all mocks completely
    vi.resetAllMocks()
    mockProvisionElectricResources.mockResolvedValue({
      source_id: 'test-source-id',
      secret: 'test-secret',
      DATABASE_URL: 'postgresql://test:test@localhost:5432/test',
    })
    mockSetupTemplate.mockResolvedValue(undefined)
  })

  afterEach(() => {
    process.argv = originalArgv
    vi.restoreAllMocks()
  })

  describe('main', () => {
    it('should successfully create an app with valid name', async () => {
      process.argv = ['node', 'cli.js', 'my-test-app']

      await main()

      expect(mockProvisionElectricResources).toHaveBeenCalledOnce()
      expect(mockSetupTemplate).toHaveBeenCalledWith('my-test-app', {
        source_id: 'test-source-id',
        secret: 'test-secret',
        DATABASE_URL: 'postgresql://test:test@localhost:5432/test',
      })

      expect(mockConsoleLog).toHaveBeenCalledWith('Creating app: my-test-app')
      expect(mockConsoleLog).toHaveBeenCalledWith('Provisioning resources...')
      expect(mockConsoleLog).toHaveBeenCalledWith('Setting up template...')
      expect(mockConsoleLog).toHaveBeenCalledWith('Setup complete')
    })

    it('should accept app names with letters, numbers, hyphens, and underscores', async () => {
      const validNames = ['my-app', 'my_app', 'myapp123', 'My-App_123']

      for (const appName of validNames) {
        vi.clearAllMocks()
        process.argv = ['node', 'cli.js', appName]

        await main()

        expect(mockProvisionElectricResources).toHaveBeenCalledOnce()
        expect(mockSetupTemplate).toHaveBeenCalledWith(appName, expect.any(Object))
        expect(mockProcessExit).not.toHaveBeenCalled()
      }
    })

    it('should exit with error when no app name provided', async () => {
      process.argv = ['node', 'cli.js']

      await main()

      expect(mockConsoleError).toHaveBeenCalledWith('Usage: quickstart <app-name>')
      expect(mockProcessExit).toHaveBeenCalledWith(1)
      expect(mockProvisionElectricResources).not.toHaveBeenCalled()
      expect(mockSetupTemplate).not.toHaveBeenCalled()
    })

    it('should exit with error for invalid app names', async () => {
      const invalidNames = [
        'my app',     // space
        'my@app',     // special character
        'my.app',     // dot
        'my/app',     // slash
        'my\\app',    // backslash
        'my app!',    // exclamation mark
      ]

      for (const appName of invalidNames) {
        vi.clearAllMocks()
        process.argv = ['node', 'cli.js', appName]

        await main()

        expect(mockConsoleError).toHaveBeenCalledWith(
          'App name must contain only letters, numbers, hyphens, and underscores'
        )
        expect(mockProcessExit).toHaveBeenCalledWith(1)
        expect(mockProvisionElectricResources).not.toHaveBeenCalled()
        expect(mockSetupTemplate).not.toHaveBeenCalled()
      }
    })

    it('should handle provisioning errors', async () => {
      process.argv = ['node', 'cli.js', 'test-app']
      const provisionError = new Error('Provisioning failed')
      mockProvisionElectricResources.mockRejectedValue(provisionError)

      await main()

      expect(mockConsoleError).toHaveBeenCalledWith(
        'Setup failed:',
        'Provisioning failed'
      )
      expect(mockProcessExit).toHaveBeenCalledWith(1)
      expect(mockSetupTemplate).not.toHaveBeenCalled()
    })

    it('should handle template setup errors', async () => {
      process.argv = ['node', 'cli.js', 'test-app']
      const setupError = new Error('Template setup failed')
      mockSetupTemplate.mockRejectedValue(setupError)

      await main()

      expect(mockConsoleError).toHaveBeenCalledWith(
        'Setup failed:',
        'Template setup failed'
      )
      expect(mockProcessExit).toHaveBeenCalledWith(1)
    })

    it('should handle non-Error exceptions', async () => {
      process.argv = ['node', 'cli.js', 'test-app']
      mockProvisionElectricResources.mockRejectedValue('String error')

      await main()

      expect(mockConsoleError).toHaveBeenCalledWith(
        'Setup failed:',
        'String error'
      )
      expect(mockProcessExit).toHaveBeenCalledWith(1)
    })

    it('should display correct completion messages and next steps', async () => {
      process.argv = ['node', 'cli.js', 'my-awesome-app']

      await main()

      expect(mockConsoleLog).toHaveBeenCalledWith('Setup complete')
      expect(mockConsoleLog).toHaveBeenCalledWith('')
      expect(mockConsoleLog).toHaveBeenCalledWith('Next steps:')
      expect(mockConsoleLog).toHaveBeenCalledWith('  cd my-awesome-app')
      expect(mockConsoleLog).toHaveBeenCalledWith('  pnpm dev')
      expect(mockConsoleLog).toHaveBeenCalledWith('')
      expect(mockConsoleLog).toHaveBeenCalledWith('Commands:')
      expect(mockConsoleLog).toHaveBeenCalledWith('  pnpm psql     # Connect to database')
      expect(mockConsoleLog).toHaveBeenCalledWith('  pnpm claim    # Claim resources')
      expect(mockConsoleLog).toHaveBeenCalledWith('  pnpm deploy   # Deploy to Netlify')
      expect(mockConsoleLog).toHaveBeenCalledWith('')
      expect(mockConsoleLog).toHaveBeenCalledWith('Tutorial: https://electric-sql.com/docs')
    })

    it('should handle multiple arguments and use only the first one', async () => {
      process.argv = ['node', 'cli.js', 'first-app', 'second-app', 'third-app']

      await main()

      expect(mockConsoleLog).toHaveBeenCalledWith('Creating app: first-app')
      expect(mockSetupTemplate).toHaveBeenCalledWith('first-app', expect.any(Object))
    })
  })

  describe('CLI entry point check', () => {
    it('should run main when called as a script', async () => {
      // Mock import.meta.url and process.argv[1] to simulate direct execution
      const originalImportMetaUrl = import.meta.url
      const mockMainFn = vi.fn().mockResolvedValue(undefined)
      
      // This test verifies the entry point logic, but it's tricky to test
      // the actual import.meta.url === file://${process.argv[1]} check
      // in a unit test environment. The logic is simple enough that we can
      // be confident it works based on integration testing.
      expect(typeof main).toBe('function')
    })
  })
})