defmodule Electric.Postgres.Extension.Migrations.Migration_20230921161418_ProxyCompatibility do
  alias Electric.Postgres.Extension

  @behaviour Extension.Migration

  @impl true
  def version, do: 2023_09_21_161418

  @impl true
  def up(schema) do
    ddl_table = Extension.ddl_table()
    version_table = Extension.version_table()
    txts_type = Extension.txts_type()

    # FROM:
    # CREATE TABLE #{version_table} (
    #     txid #{@txid_type} NOT NULL,
    #     txts timestamp with time zone NOT NULL,
    #     version varchar(255) NOT NULL,
    #     PRIMARY KEY (txid, txts),
    #     CONSTRAINT "migration_unique_version" UNIQUE (version),
    #     CONSTRAINT "migration_unique_fk" UNIQUE (txid, txts, version)
    # );
    # CREATE TABLE #{ddl_table} (
    #     id int8 NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    #     txid #{@txid_type} NOT NULL,
    #     txts timestamp with time zone NOT NULL,
    #     version varchar(255) NOT NULL,
    #     query text NOT NULL,
    #     FOREIGN KEY (txid, txts, version) REFERENCES #{version_table} (txid, txts, version)
    # );
    #
    # TO:
    #
    # CREATE TABLE #{version_table} (
    #     txid #{@txid_type} DEFAULT #{schema}.current_xact_id() NOT NULL,
    #     txts #{@txts_type} DEFAULT #{schema}.current_xact_ts() NOT NULL,
    #     version text NOT NULL,
    #     inserted_at timestamp with time zone DEFAULT transaction_timestamp() NOT NULL,
    #     PRIMARY KEY (txid, txts),
    #     CONSTRAINT "migration_unique_version" UNIQUE (version)
    # );
    #
    # CREATE TABLE #{ddl_table} (
    #     id int8 NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    #     txid #{@txid_type} DEFAULT #{schema}.current_xact_id() NOT NULL,
    #     txts #{@txts_type} DEFAULT #{schema}.current_xact_ts() NOT NULL,
    #     query text NOT NULL,
    #     inserted_at timestamp with time zone DEFAULT transaction_timestamp() NOT NULL
    # );
    [
      Extension.Functions.by_name(:current_xact_ts),
      Extension.Functions.by_name(:current_xact_id),
      """
      ALTER TABLE #{ddl_table} DROP CONSTRAINT ddl_table_unique_migrations;
      """,
      """
      ALTER TABLE #{ddl_table} DROP CONSTRAINT ddl_commands_txid_txts_version_fkey;
      """,
      """
      ALTER TABLE #{version_table} ALTER COLUMN txts TYPE #{txts_type} USING (extract(epoch from txts) * 1000000)::#{txts_type};
      """,
      """
      ALTER TABLE #{version_table}
        ADD COLUMN inserted_at timestamp with time zone DEFAULT transaction_timestamp() NOT NULL,
        ALTER COLUMN txts SET DEFAULT #{schema}.current_xact_ts(),
        ALTER COLUMN txid SET DEFAULT #{schema}.current_xact_id();
      """,
      """
      ALTER TABLE #{version_table} DROP CONSTRAINT IF EXISTS migration_unique_fk;
      """,
      """
      ALTER TABLE #{ddl_table} ALTER COLUMN txts TYPE #{txts_type} USING (extract(epoch from txts) * 1000000)::#{txts_type};
      """,
      """
      ALTER TABLE #{ddl_table} DROP COLUMN version;
      """,
      """
      ALTER TABLE #{ddl_table}
        ALTER COLUMN txts SET DEFAULT #{schema}.current_xact_ts(),
        ALTER COLUMN txid SET DEFAULT #{schema}.current_xact_id();
      """,
      """
      ALTER TABLE #{ddl_table}
        ADD CONSTRAINT ddl_table_unique_migrations
        UNIQUE (txid, txts, query);
      """,
      # functions that are being re-defined as procedures:
      """
      DROP FUNCTION IF EXISTS #{schema}.capture_ddl;
      """,
      """
      DROP FUNCTION IF EXISTS #{schema}.create_active_migration;
      """,
      """
      DROP FUNCTION IF EXISTS #{schema}.migration_version;
      """,
      # we don't track indexes within pg anymore
      """
      DROP TABLE IF EXISTS #{schema}.electrified_idx;
      """
    ]
  end

  @impl true
  def down(_), do: []
end
