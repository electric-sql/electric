defmodule Electric.Postgres.Extension.Migrations.Migration_20230921161418_ProxyCompatibility do
  alias Electric.Postgres.Extension

  @behaviour Extension.Migration

  @impl true
  def version, do: 2023_09_21_161418

  @impl true
  def up(schema) do
    ddl_table = Extension.ddl_table()
    version_table = Extension.version_table()
    txid_type = Extension.txid_type()
    txts_type = Extension.txts_type()

    # FROM:
    # CREATE TABLE #{version_table} (
    #     txid #{@txid_type} NOT NULL,
    #     txts timestamp with time zone NOT NULL,
    #     version varchar(255) NOT NULL,
    #     PRIMARY KEY (txid, txts),
    #     CONSTRAINT "migration_unique_version" UNIQUE (version),
    #     CONSTRAINT "migration_unique_fk" UNIQUE (txid, txts, version)
    # );
    # CREATE TABLE #{ddl_table} (
    #     id int8 NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    #     txid #{@txid_type} NOT NULL,
    #     txts timestamp with time zone NOT NULL,
    #     version varchar(255) NOT NULL,
    #     query text NOT NULL,
    #     FOREIGN KEY (txid, txts, version) REFERENCES #{version_table} (txid, txts, version)
    # );
    #
    # TO:
    #
    # CREATE TABLE #{version_table} (
    #     txid #{@txid_type} DEFAULT #{schema}.current_xact_id() NOT NULL,
    #     txts #{@txts_type} DEFAULT #{schema}.current_xact_ts() NOT NULL,
    #     version text NOT NULL,
    #     inserted_at timestamp with time zone DEFAULT transaction_timestamp() NOT NULL,
    #     PRIMARY KEY (txid, txts),
    #     CONSTRAINT "migration_unique_version" UNIQUE (version)
    # );
    #
    # CREATE TABLE #{ddl_table} (
    #     id int8 NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    #     txid #{@txid_type} DEFAULT #{schema}.current_xact_id() NOT NULL,
    #     txts #{@txts_type} DEFAULT #{schema}.current_xact_ts() NOT NULL,
    #     query text NOT NULL,
    #     inserted_at timestamp with time zone DEFAULT transaction_timestamp() NOT NULL
    # );
    [
      """
      CREATE OR REPLACE FUNCTION #{schema}.current_xact_ts() RETURNS #{txts_type} SECURITY DEFINER AS $function$
      BEGIN
          RETURN (extract(epoch from transaction_timestamp()) * 1000000)::#{txts_type};
      END;
      $function$ LANGUAGE PLPGSQL STABLE STRICT PARALLEL SAFE;
      """,
      """
      CREATE OR REPLACE FUNCTION #{schema}.current_xact_id() RETURNS #{txid_type} SECURITY DEFINER AS $function$
      BEGIN
          RETURN pg_current_xact_id();
      END;
      -- PARALLEL UNSAFE because `pg_current_xact_id` is parallel unsafe
      $function$ LANGUAGE PLPGSQL STABLE STRICT PARALLEL UNSAFE;
      """,
      """
      ALTER TABLE #{ddl_table} DROP CONSTRAINT ddl_table_unique_migrations;
      """,
      """
      ALTER TABLE #{ddl_table} DROP CONSTRAINT ddl_commands_txid_txts_version_fkey;
      """,
      """
      ALTER TABLE #{version_table} ALTER COLUMN txts TYPE #{txts_type} USING (extract(epoch from txts) * 1000000)::#{txts_type};
      """,
      """
      ALTER TABLE #{version_table}
        ADD COLUMN inserted_at timestamp with time zone DEFAULT transaction_timestamp() NOT NULL,
        ALTER COLUMN txts SET DEFAULT #{schema}.current_xact_ts(),
        ALTER COLUMN txid SET DEFAULT #{schema}.current_xact_id();
      """,
      """
      ALTER TABLE #{version_table} DROP CONSTRAINT IF EXISTS migration_unique_fk;
      """,
      """
      ALTER TABLE #{ddl_table} ALTER COLUMN txts TYPE #{txts_type} USING (extract(epoch from txts) * 1000000)::#{txts_type};
      """,
      """
      ALTER TABLE #{ddl_table} DROP COLUMN version;
      """,
      """
      ALTER TABLE #{ddl_table}
        ALTER COLUMN txts SET DEFAULT #{schema}.current_xact_ts(),
        ALTER COLUMN txts SET NOT NULL,
        ALTER COLUMN txid SET DEFAULT #{schema}.current_xact_id();
      """,
      """
      ALTER TABLE #{ddl_table}
        ADD CONSTRAINT ddl_table_unique_migrations
        UNIQUE (txid, txts, query);
      """,
      """
      DROP EVENT TRIGGER IF EXISTS "#{schema}_event_trigger_ddl_end CASCADE";
      """,
      """
      DROP EVENT TRIGGER IF EXISTS "#{schema}_event_trigger_sql_drop CASCADE";
      """,
      # functions that are being re-defined as procedures:
      """
      DROP FUNCTION IF EXISTS capture_ddl;
      """,
      """
      DROP FUNCTION IF EXISTS create_active_migration;
      """,
      """
      DROP FUNCTION IF EXISTS migration_version;
      """,
      # we don't track indexes within pg anymore
      """
      DROP TABLE IF EXISTS #{schema}.electrified_idx;
      """
    ]
  end

  @impl true
  def down(_), do: []
end
